/* soapStub.h
   Generated by gSOAP 2.8.23 from ctSoap.h

Copyright(C) 2000-2015, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef soapStub_H
#define soapStub_H
#include <list>
#include <vector>
#include <deque>
#include "stdsoap2.h"
#if GSOAP_VERSION != 20823
# error "GSOAP VERSION 20823 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns__SysBackupEvent
#define SOAP_TYPE_ns__SysBackupEvent (72)
/* ns:SysBackupEvent */
enum ns__SysBackupEvent { EVENT_NONE = -5, EVENT_GET_FILENAME_CONFIG = -4, EVENT_GET_FILENAME_FIRMWARE = -3, EVENT_SET_FILENAME_CONFIG = -2, EVENT_SET_FILENAME_FIRMWARE = -1, EVENT_BACKUP_CONFIGURATION = 0, EVENT_UPDATE_CONFIGURATION = 1, EVENT_BACKUP_FIRMWARE = 2, EVENT_UPDATE_FIRMWARE = 3 };
#endif

#ifndef SOAP_TYPE_ns__SysShutdownEvent
#define SOAP_TYPE_ns__SysShutdownEvent (83)
/* ns:SysShutdownEvent */
enum ns__SysShutdownEvent { EVENT_SHUTDOWN = 0, EVENT_REBOOT = 1, EVENT_LOGOUT = 2 };
#endif

#ifndef SOAP_TYPE_SysGraphMode_t
#define SOAP_TYPE_SysGraphMode_t (87)
/* SysGraphMode-t */
enum SysGraphMode_t { GRAPH_MODE_HOUR = 0, GRAPH_MODE_DAY = 1, GRAPH_MODE_WEEK = 2, GRAPH_MODE_MONTH = 3, GRAPH_MODE_YEAR = 4 };
#endif

#ifndef SOAP_TYPE_SysGraphNumPoint_t
#define SOAP_TYPE_SysGraphNumPoint_t (88)
/* SysGraphNumPoint-t */
enum SysGraphNumPoint_t { NUMS_POINT_HOUR = 7, NUMS_POINT_DAY = 13, NUMS_POINT_WEEK = 7, NUMS_POINT_MONTH = 12, NUMS_POINT_YEAR = 6 };
#endif

#ifndef SOAP_TYPE_legend_t
#define SOAP_TYPE_legend_t (117)
/* legend-t */
enum legend_t { LEGEND_LAN = 0, LEGEND_INTERNET = 1, LEGEND_DMZ = 2, LEGEND_FIREWALL = 3, LEGEND_IPSEC = 4, LEGEND_SSLVPN = 5, LEGEND_MULTICAST = 6 };
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_ns__Data
#define SOAP_TYPE_ns__Data (10)
/* Base64 schema type: */
class SOAP_CMAC ns__Data
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of type xsd:string */
	char *type;	/* optional element of type xsd:string */
	char *options;	/* optional element of type xsd:string */
	ns__Data();	/* transient */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 10; } /* = unique type id SOAP_TYPE_ns__Data */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	virtual ~ns__Data() { }
};
#endif

#ifndef SOAP_TYPE_arrayOfData
#define SOAP_TYPE_arrayOfData (18)
/* SOAP encoded array of ns:Data schema type: */
class SOAP_CMAC arrayOfData
{
public:
	ns__Data *__ptr;
	int __size;
	arrayOfData();	/* transient */
	arrayOfData(struct soap *_param_1, int _param_2);	/* transient */
	virtual ~arrayOfData();	/* transient */
	int size();	/* transient */
	void resize(int _param_3);	/* transient */
	ns__Data &operator[](int _param_4) const;	/* transient */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique type id SOAP_TYPE_arrayOfData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
};
#endif

#ifndef SOAP_TYPE_arrayOfName
#define SOAP_TYPE_arrayOfName (29)
/* SOAP encoded array of xsd:string schema type: */
class SOAP_CMAC arrayOfName
{
public:
	char **__ptr;
	int __size;
	arrayOfName();	/* transient */
	arrayOfName(struct soap *_param_5, int _param_6);	/* transient */
	virtual ~arrayOfName();	/* transient */
	int size();	/* transient */
	void resize(int _param_7);	/* transient */
	char *&operator[](int _param_8) const;	/* transient */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique type id SOAP_TYPE_arrayOfName */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
};
#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_ns__putDataResponse
#define SOAP_TYPE_ns__putDataResponse (44)
/* ns:putDataResponse */
struct ns__putDataResponse
{
public:
	arrayOfName *names;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ArrayOfstring */
public:
	int soap_type() const { return 44; } /* = unique type id SOAP_TYPE_ns__putDataResponse */
};
#endif

#ifndef SOAP_TYPE_ns__putData
#define SOAP_TYPE_ns__putData (45)
/* ns:putData */
struct ns__putData
{
public:
	std::vector<std::string >*nameList;	/* optional element of type xsd:string */
	arrayOfData *data;	/* optional element of type ArrayOfData */
public:
	int soap_type() const { return 45; } /* = unique type id SOAP_TYPE_ns__putData */
};
#endif

#ifndef SOAP_TYPE_ns__getDataResponse
#define SOAP_TYPE_ns__getDataResponse (47)
/* ns:getDataResponse */
struct ns__getDataResponse
{
public:
	arrayOfData *data;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ArrayOfData */
public:
	int soap_type() const { return 47; } /* = unique type id SOAP_TYPE_ns__getDataResponse */
};
#endif

#ifndef SOAP_TYPE_ns__getData
#define SOAP_TYPE_ns__getData (48)
/* ns:getData */
struct ns__getData
{
public:
	arrayOfName *names;	/* optional element of type ArrayOfstring */
public:
	int soap_type() const { return 48; } /* = unique type id SOAP_TYPE_ns__getData */
};
#endif

#ifndef SOAP_TYPE_ns__getImageResponse
#define SOAP_TYPE_ns__getImageResponse (50)
/* ns:getImageResponse */
struct ns__getImageResponse
{
public:
	ns__Data image;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns:Data */
public:
	int soap_type() const { return 50; } /* = unique type id SOAP_TYPE_ns__getImageResponse */
};
#endif

#ifndef SOAP_TYPE_ns__getImage
#define SOAP_TYPE_ns__getImage (51)
/* ns:getImage */
struct ns__getImage
{
public:
	char *name;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 51; } /* = unique type id SOAP_TYPE_ns__getImage */
};
#endif

#ifndef SOAP_TYPE_ns__noResponse
#define SOAP_TYPE_ns__noResponse (52)
/* ns:noResponse */
struct ns__noResponse
{
public:
	int soap_type() const { return 52; } /* = unique type id SOAP_TYPE_ns__noResponse */
};
#endif

#ifndef SOAP_TYPE_ns__loginResponse
#define SOAP_TYPE_ns__loginResponse (56)
/* ns:loginResponse */
struct ns__loginResponse
{
public:
	bool *ret;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:boolean */
public:
	int soap_type() const { return 56; } /* = unique type id SOAP_TYPE_ns__loginResponse */
};
#endif

#ifndef SOAP_TYPE_ns__login
#define SOAP_TYPE_ns__login (57)
/* ns:login */
struct ns__login
{
public:
	char *username;	/* optional element of type xsd:string */
	char *passwd;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 57; } /* = unique type id SOAP_TYPE_ns__login */
};
#endif

#ifndef SOAP_TYPE_RuntimeInfo_t
#define SOAP_TYPE_RuntimeInfo_t (58)
/* RuntimeInfo-t */
class SOAP_CMAC RuntimeInfo_t
{
public:
	bool isConnected;	/* required element of type xsd:boolean */
	float inSpeed;	/* required element of type xsd:float */
	float outSpeed;	/* required element of type xsd:float */
public:
	virtual int soap_type() const { return 58; } /* = unique type id SOAP_TYPE_RuntimeInfo_t */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         RuntimeInfo_t() { RuntimeInfo_t::soap_default(NULL); }
	virtual ~RuntimeInfo_t() { }
};
#endif

#ifndef SOAP_TYPE_ns__getRuntimeInfoResponse
#define SOAP_TYPE_ns__getRuntimeInfoResponse (63)
/* ns:getRuntimeInfoResponse */
struct ns__getRuntimeInfoResponse
{
public:
	RuntimeInfo_t *ret;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type RuntimeInfo-t */
public:
	int soap_type() const { return 63; } /* = unique type id SOAP_TYPE_ns__getRuntimeInfoResponse */
};
#endif

#ifndef SOAP_TYPE_ns__getRuntimeInfo
#define SOAP_TYPE_ns__getRuntimeInfo (64)
/* ns:getRuntimeInfo */
struct ns__getRuntimeInfo
{
public:
	void *_param_9;	/* transient */
public:
	int soap_type() const { return 64; } /* = unique type id SOAP_TYPE_ns__getRuntimeInfo */
};
#endif

#ifndef SOAP_TYPE_IfInfot_t
#define SOAP_TYPE_IfInfot_t (65)
/* IfInfot-t */
class SOAP_CMAC IfInfot_t
{
public:
	std::string ifname;	/* required element of type xsd:string */
	std::string ip;	/* required element of type xsd:string */
	std::string netmask;	/* required element of type xsd:string */
	std::string mac;	/* required element of type xsd:string */
	int mtu;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 65; } /* = unique type id SOAP_TYPE_IfInfot_t */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         IfInfot_t() { IfInfot_t::soap_default(NULL); }
	virtual ~IfInfot_t() { }
};
#endif

#ifndef SOAP_TYPE_NetInterface_t
#define SOAP_TYPE_NetInterface_t (66)
/* NetInterface-t */
class SOAP_CMAC NetInterface_t
{
public:
	std::vector<IfInfot_t >lanIfList;	/* optional element of type IfInfot-t */
	std::vector<IfInfot_t >netIfList;	/* optional element of type IfInfot-t */
	std::string gw;	/* required element of type xsd:string */
	std::string dns;	/* required element of type xsd:string */
public:
	virtual int soap_type() const { return 66; } /* = unique type id SOAP_TYPE_NetInterface_t */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         NetInterface_t() { NetInterface_t::soap_default(NULL); }
	virtual ~NetInterface_t() { }
};
#endif

#ifndef SOAP_TYPE_ns__getSysHomeInterfaceResponse
#define SOAP_TYPE_ns__getSysHomeInterfaceResponse (70)
/* ns:getSysHomeInterfaceResponse */
struct ns__getSysHomeInterfaceResponse
{
public:
	NetInterface_t *ret;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type NetInterface-t */
public:
	int soap_type() const { return 70; } /* = unique type id SOAP_TYPE_ns__getSysHomeInterfaceResponse */
};
#endif

#ifndef SOAP_TYPE_ns__getSysHomeInterface
#define SOAP_TYPE_ns__getSysHomeInterface (71)
/* ns:getSysHomeInterface */
struct ns__getSysHomeInterface
{
public:
	void *_param_10;	/* transient */
public:
	int soap_type() const { return 71; } /* = unique type id SOAP_TYPE_ns__getSysHomeInterface */
};
#endif

#ifndef SOAP_TYPE_SysBackupRet_t
#define SOAP_TYPE_SysBackupRet_t (73)
/* SysBackupRet-t */
class SOAP_CMAC SysBackupRet_t
{
public:
	std::string filename;	/* required element of type xsd:string */
public:
	virtual int soap_type() const { return 73; } /* = unique type id SOAP_TYPE_SysBackupRet_t */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         SysBackupRet_t() { SysBackupRet_t::soap_default(NULL); }
	virtual ~SysBackupRet_t() { }
};
#endif

#ifndef SOAP_TYPE_ns__SysBackupHandleResponse
#define SOAP_TYPE_ns__SysBackupHandleResponse (76)
/* ns:SysBackupHandleResponse */
struct ns__SysBackupHandleResponse
{
public:
	SysBackupRet_t *ret;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type SysBackupRet-t */
public:
	int soap_type() const { return 76; } /* = unique type id SOAP_TYPE_ns__SysBackupHandleResponse */
};
#endif

#ifndef SOAP_TYPE_ns__SysBackupHandle
#define SOAP_TYPE_ns__SysBackupHandle (77)
/* ns:SysBackupHandle */
struct ns__SysBackupHandle
{
public:
	enum ns__SysBackupEvent in;	/* required element of type ns:SysBackupEvent */
	char *path;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 77; } /* = unique type id SOAP_TYPE_ns__SysBackupHandle */
};
#endif

#ifndef SOAP_TYPE_SysInfo_t
#define SOAP_TYPE_SysInfo_t (78)
/* SysInfo-t */
class SOAP_CMAC SysInfo_t
{
public:
	std::string ctfw_version;	/* required element of type xsd:string */
	std::string cpu;	/* required element of type xsd:string */
	std::string memory;	/* required element of type xsd:string */
public:
	virtual int soap_type() const { return 78; } /* = unique type id SOAP_TYPE_SysInfo_t */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         SysInfo_t() { SysInfo_t::soap_default(NULL); }
	virtual ~SysInfo_t() { }
};
#endif

#ifndef SOAP_TYPE_ns__getSysSysInfoResponse
#define SOAP_TYPE_ns__getSysSysInfoResponse (81)
/* ns:getSysSysInfoResponse */
struct ns__getSysSysInfoResponse
{
public:
	SysInfo_t *ret;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type SysInfo-t */
public:
	int soap_type() const { return 81; } /* = unique type id SOAP_TYPE_ns__getSysSysInfoResponse */
};
#endif

#ifndef SOAP_TYPE_ns__getSysSysInfo
#define SOAP_TYPE_ns__getSysSysInfo (82)
/* ns:getSysSysInfo */
struct ns__getSysSysInfo
{
public:
	void *_param_11;	/* transient */
public:
	int soap_type() const { return 82; } /* = unique type id SOAP_TYPE_ns__getSysSysInfo */
};
#endif

#ifndef SOAP_TYPE_ns__SysShutdownHandle
#define SOAP_TYPE_ns__SysShutdownHandle (86)
/* ns:SysShutdownHandle */
struct ns__SysShutdownHandle
{
public:
	enum ns__SysShutdownEvent in;	/* required element of type ns:SysShutdownEvent */
public:
	int soap_type() const { return 86; } /* = unique type id SOAP_TYPE_ns__SysShutdownHandle */
};
#endif

#ifndef SOAP_TYPE_GraphData_t
#define SOAP_TYPE_GraphData_t (89)
/* GraphData-t */
class SOAP_CMAC GraphData_t
{
public:
	std::vector<int >grapData;	/* optional element of type xsd:int */
public:
	virtual int soap_type() const { return 89; } /* = unique type id SOAP_TYPE_GraphData_t */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         GraphData_t() { GraphData_t::soap_default(NULL); }
	virtual ~GraphData_t() { }
};
#endif

#ifndef SOAP_TYPE_SystemData_t
#define SOAP_TYPE_SystemData_t (91)
/* SystemData-t */
class SOAP_CMAC SystemData_t
{
public:
	std::vector<GraphData_t >cpuData;	/* optional element of type GraphData-t */
	std::vector<GraphData_t >memoryData;	/* optional element of type GraphData-t */
public:
	virtual int soap_type() const { return 91; } /* = unique type id SOAP_TYPE_SystemData_t */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         SystemData_t() { SystemData_t::soap_default(NULL); }
	virtual ~SystemData_t() { }
};
#endif

#ifndef SOAP_TYPE_ns__getStatusSystemGraphResponse
#define SOAP_TYPE_ns__getStatusSystemGraphResponse (95)
/* ns:getStatusSystemGraphResponse */
struct ns__getStatusSystemGraphResponse
{
public:
	SystemData_t *ret;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type SystemData-t */
public:
	int soap_type() const { return 95; } /* = unique type id SOAP_TYPE_ns__getStatusSystemGraphResponse */
};
#endif

#ifndef SOAP_TYPE_ns__getStatusSystemGraph
#define SOAP_TYPE_ns__getStatusSystemGraph (96)
/* ns:getStatusSystemGraph */
struct ns__getStatusSystemGraph
{
public:
	enum SysGraphMode_t mode;	/* required element of type SysGraphMode-t */
public:
	int soap_type() const { return 96; } /* = unique type id SOAP_TYPE_ns__getStatusSystemGraph */
};
#endif

#ifndef SOAP_TYPE_NetTraffic_t
#define SOAP_TYPE_NetTraffic_t (97)
/* NetTraffic-t */
class SOAP_CMAC NetTraffic_t
{
public:
	float max;	/* required element of type xsd:float */
	float avg;	/* required element of type xsd:float */
	float min;	/* required element of type xsd:float */
	float current;	/* required element of type xsd:float */
public:
	virtual int soap_type() const { return 97; } /* = unique type id SOAP_TYPE_NetTraffic_t */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         NetTraffic_t() { NetTraffic_t::soap_default(NULL); }
	virtual ~NetTraffic_t() { }
};
#endif

#ifndef SOAP_TYPE_NetworkData_t
#define SOAP_TYPE_NetworkData_t (98)
/* NetworkData-t */
class SOAP_CMAC NetworkData_t
{
public:
	std::vector<GraphData_t >graphListData;	/* optional element of type GraphData-t */
	std::vector<NetTraffic_t >netListTraffic;	/* optional element of type NetTraffic-t */
public:
	virtual int soap_type() const { return 98; } /* = unique type id SOAP_TYPE_NetworkData_t */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         NetworkData_t() { NetworkData_t::soap_default(NULL); }
	virtual ~NetworkData_t() { }
};
#endif

#ifndef SOAP_TYPE_ns__getStatusNetworkExternalResponse
#define SOAP_TYPE_ns__getStatusNetworkExternalResponse (102)
/* ns:getStatusNetworkExternalResponse */
struct ns__getStatusNetworkExternalResponse
{
public:
	NetworkData_t *ret;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type NetworkData-t */
public:
	int soap_type() const { return 102; } /* = unique type id SOAP_TYPE_ns__getStatusNetworkExternalResponse */
};
#endif

#ifndef SOAP_TYPE_ns__getStatusNetworkExternal
#define SOAP_TYPE_ns__getStatusNetworkExternal (103)
/* ns:getStatusNetworkExternal */
struct ns__getStatusNetworkExternal
{
public:
	enum SysGraphMode_t mode;	/* required element of type SysGraphMode-t */
public:
	int soap_type() const { return 103; } /* = unique type id SOAP_TYPE_ns__getStatusNetworkExternal */
};
#endif

#ifndef SOAP_TYPE_ns__getStatusNetworkInternalResponse
#define SOAP_TYPE_ns__getStatusNetworkInternalResponse (105)
/* ns:getStatusNetworkInternalResponse */
struct ns__getStatusNetworkInternalResponse
{
public:
	NetworkData_t *ret;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type NetworkData-t */
public:
	int soap_type() const { return 105; } /* = unique type id SOAP_TYPE_ns__getStatusNetworkInternalResponse */
};
#endif

#ifndef SOAP_TYPE_ns__getStatusNetworkInternal
#define SOAP_TYPE_ns__getStatusNetworkInternal (106)
/* ns:getStatusNetworkInternal */
struct ns__getStatusNetworkInternal
{
public:
	enum SysGraphMode_t mode;	/* required element of type SysGraphMode-t */
public:
	int soap_type() const { return 106; } /* = unique type id SOAP_TYPE_ns__getStatusNetworkInternal */
};
#endif

#ifndef SOAP_TYPE_ns__getStatusNetworkOtherResponse
#define SOAP_TYPE_ns__getStatusNetworkOtherResponse (108)
/* ns:getStatusNetworkOtherResponse */
struct ns__getStatusNetworkOtherResponse
{
public:
	NetworkData_t *ret;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type NetworkData-t */
public:
	int soap_type() const { return 108; } /* = unique type id SOAP_TYPE_ns__getStatusNetworkOtherResponse */
};
#endif

#ifndef SOAP_TYPE_ns__getStatusNetworkOther
#define SOAP_TYPE_ns__getStatusNetworkOther (109)
/* ns:getStatusNetworkOther */
struct ns__getStatusNetworkOther
{
public:
	enum SysGraphMode_t mode;	/* required element of type SysGraphMode-t */
public:
	int soap_type() const { return 109; } /* = unique type id SOAP_TYPE_ns__getStatusNetworkOther */
};
#endif

#ifndef SOAP_TYPE_StatusServices_t
#define SOAP_TYPE_StatusServices_t (110)
/* StatusServices-t */
class SOAP_CMAC StatusServices_t
{
public:
	std::string name;	/* required element of type xsd:string */
	bool isRunning;	/* required element of type xsd:boolean */
	int pid;	/* required element of type xsd:int */
	float memory;	/* required element of type xsd:float */
public:
	virtual int soap_type() const { return 110; } /* = unique type id SOAP_TYPE_StatusServices_t */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         StatusServices_t() { StatusServices_t::soap_default(NULL); }
	virtual ~StatusServices_t() { }
};
#endif

#ifndef SOAP_TYPE_ns__getStatusServicesResponse
#define SOAP_TYPE_ns__getStatusServicesResponse (115)
/* ns:getStatusServicesResponse */
struct ns__getStatusServicesResponse
{
public:
	std::vector<StatusServices_t >*ret;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type StatusServicesList-t */
public:
	int soap_type() const { return 115; } /* = unique type id SOAP_TYPE_ns__getStatusServicesResponse */
};
#endif

#ifndef SOAP_TYPE_ns__getStatusServices
#define SOAP_TYPE_ns__getStatusServices (116)
/* ns:getStatusServices */
struct ns__getStatusServices
{
public:
	void *_param_12;	/* transient */
public:
	int soap_type() const { return 116; } /* = unique type id SOAP_TYPE_ns__getStatusServices */
};
#endif

#ifndef SOAP_TYPE_ConnTrack_t
#define SOAP_TYPE_ConnTrack_t (118)
/* ConnTrack-t */
class SOAP_CMAC ConnTrack_t
{
public:
	int protocol;	/* required element of type xsd:int */
	std::string sip;	/* required element of type xsd:string */
	std::string dip;	/* required element of type xsd:string */
	int sport;	/* required element of type xsd:int */
	int dport;	/* required element of type xsd:int */
	float downSpeed;	/* required element of type xsd:float */
	float upSpeed;	/* required element of type xsd:float */
	int connStatus;	/* required element of type xsd:int */
	float expires;	/* required element of type xsd:float */
	int slegend;	/* required element of type xsd:int */
	int dlegend;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 118; } /* = unique type id SOAP_TYPE_ConnTrack_t */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ConnTrack_t() { ConnTrack_t::soap_default(NULL); }
	virtual ~ConnTrack_t() { }
};
#endif

#ifndef SOAP_TYPE_ns__getStatusConnectionResponse
#define SOAP_TYPE_ns__getStatusConnectionResponse (123)
/* ns:getStatusConnectionResponse */
struct ns__getStatusConnectionResponse
{
public:
	std::vector<ConnTrack_t >*ret;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type StatusConnList-t */
public:
	int soap_type() const { return 123; } /* = unique type id SOAP_TYPE_ns__getStatusConnectionResponse */
};
#endif

#ifndef SOAP_TYPE_ns__getStatusConnection
#define SOAP_TYPE_ns__getStatusConnection (124)
/* ns:getStatusConnection */
struct ns__getStatusConnection
{
public:
	void *_param_13;	/* transient */
public:
	int soap_type() const { return 124; } /* = unique type id SOAP_TYPE_ns__getStatusConnection */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (125)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 125; } /* = unique type id SOAP_TYPE_SOAP_ENV__Header */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (126)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
public:
	int soap_type() const { return 126; } /* = unique type id SOAP_TYPE_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (128)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
public:
	int soap_type() const { return 128; } /* = unique type id SOAP_TYPE_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (129)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 129; } /* = unique type id SOAP_TYPE_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (130)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
public:
	int soap_type() const { return 130; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_StatusServicesList_t
#define SOAP_TYPE_StatusServicesList_t (112)
typedef std::vector<StatusServices_t >StatusServicesList_t;
#endif

#ifndef SOAP_TYPE_StatusConnList_t
#define SOAP_TYPE_StatusConnList_t (120)
typedef std::vector<ConnTrack_t >StatusConnList_t;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Server-Side Operations                                                     *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 ns__putData(struct soap*, std::vector<std::string >*nameList, arrayOfData *data, arrayOfName *names);

SOAP_FMAC5 int SOAP_FMAC6 ns__getData(struct soap*, arrayOfName *names, arrayOfData *data);

SOAP_FMAC5 int SOAP_FMAC6 ns__getImage(struct soap*, char *name, ns__Data &image);

SOAP_FMAC5 int SOAP_FMAC6 ns__login(struct soap*, char *username, char *passwd, bool *ret);

SOAP_FMAC5 int SOAP_FMAC6 ns__getRuntimeInfo(struct soap*, void *_param_9, RuntimeInfo_t *ret);

SOAP_FMAC5 int SOAP_FMAC6 ns__getSysHomeInterface(struct soap*, void *_param_10, NetInterface_t *ret);

SOAP_FMAC5 int SOAP_FMAC6 ns__SysBackupHandle(struct soap*, enum ns__SysBackupEvent in, char *path, SysBackupRet_t *ret);

SOAP_FMAC5 int SOAP_FMAC6 ns__getSysSysInfo(struct soap*, void *_param_11, SysInfo_t *ret);

SOAP_FMAC5 int SOAP_FMAC6 ns__SysShutdownHandle(struct soap*, enum ns__SysShutdownEvent in, struct ns__noResponse *out);

SOAP_FMAC5 int SOAP_FMAC6 ns__getStatusSystemGraph(struct soap*, enum SysGraphMode_t mode, SystemData_t *ret);

SOAP_FMAC5 int SOAP_FMAC6 ns__getStatusNetworkExternal(struct soap*, enum SysGraphMode_t mode, NetworkData_t *ret);

SOAP_FMAC5 int SOAP_FMAC6 ns__getStatusNetworkInternal(struct soap*, enum SysGraphMode_t mode, NetworkData_t *ret);

SOAP_FMAC5 int SOAP_FMAC6 ns__getStatusNetworkOther(struct soap*, enum SysGraphMode_t mode, NetworkData_t *ret);

SOAP_FMAC5 int SOAP_FMAC6 ns__getStatusServices(struct soap*, void *_param_12, std::vector<StatusServices_t >*ret);

SOAP_FMAC5 int SOAP_FMAC6 ns__getStatusConnection(struct soap*, void *_param_13, std::vector<ConnTrack_t >*ret);

/******************************************************************************\
 *                                                                            *
 * Server-Side Skeletons to Invoke Service Operations                         *
 *                                                                            *
\******************************************************************************/

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve(struct soap*);

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve_request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__putData(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__getData(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__getImage(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__login(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__getRuntimeInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__getSysHomeInterface(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SysBackupHandle(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__getSysSysInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__SysShutdownHandle(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__getStatusSystemGraph(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__getStatusNetworkExternal(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__getStatusNetworkInternal(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__getStatusNetworkOther(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__getStatusServices(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__getStatusConnection(struct soap*);

/******************************************************************************\
 *                                                                            *
 * Client-Side Call Stubs                                                     *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__putData(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::vector<std::string >*nameList, arrayOfData *data, arrayOfName *names);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__getData(struct soap *soap, const char *soap_endpoint, const char *soap_action, arrayOfName *names, arrayOfData *data);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__getImage(struct soap *soap, const char *soap_endpoint, const char *soap_action, char *name, ns__Data &image);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__login(struct soap *soap, const char *soap_endpoint, const char *soap_action, char *username, char *passwd, bool *ret);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__getRuntimeInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, void *_param_9, RuntimeInfo_t *ret);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__getSysHomeInterface(struct soap *soap, const char *soap_endpoint, const char *soap_action, void *_param_10, NetInterface_t *ret);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__SysBackupHandle(struct soap *soap, const char *soap_endpoint, const char *soap_action, enum ns__SysBackupEvent in, char *path, SysBackupRet_t *ret);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__getSysSysInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, void *_param_11, SysInfo_t *ret);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__SysShutdownHandle(struct soap *soap, const char *soap_endpoint, const char *soap_action, enum ns__SysShutdownEvent in, struct ns__noResponse *out);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__getStatusSystemGraph(struct soap *soap, const char *soap_endpoint, const char *soap_action, enum SysGraphMode_t mode, SystemData_t *ret);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__getStatusNetworkExternal(struct soap *soap, const char *soap_endpoint, const char *soap_action, enum SysGraphMode_t mode, NetworkData_t *ret);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__getStatusNetworkInternal(struct soap *soap, const char *soap_endpoint, const char *soap_action, enum SysGraphMode_t mode, NetworkData_t *ret);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__getStatusNetworkOther(struct soap *soap, const char *soap_endpoint, const char *soap_action, enum SysGraphMode_t mode, NetworkData_t *ret);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__getStatusServices(struct soap *soap, const char *soap_endpoint, const char *soap_action, void *_param_12, std::vector<StatusServices_t >*ret);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__getStatusConnection(struct soap *soap, const char *soap_endpoint, const char *soap_action, void *_param_13, std::vector<ConnTrack_t >*ret);

#endif

/* End of soapStub.h */
